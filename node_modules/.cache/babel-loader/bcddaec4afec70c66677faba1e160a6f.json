{"ast":null,"code":"/*!\n * headroom.js v0.9.4 - Give your page some headroom. Hide your header until you need it\n * Copyright (c) 2017 Nick Williams - http://wicky.nillia.ms/headroom.js\n * License: MIT\n */\n(function (root, factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // COMMONJS\n    module.exports = factory();\n  } else {\n    // BROWSER\n    root.Headroom = factory();\n  }\n})(this, function () {\n  'use strict';\n  /* exported features */\n\n  var features = {\n    bind: !!function () {}.bind,\n    classList: 'classList' in document.documentElement,\n    rAF: !!(window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame)\n  };\n  window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;\n  /**\n   * Handles debouncing of events via requestAnimationFrame\n   * @see http://www.html5rocks.com/en/tutorials/speed/animations/\n   * @param {Function} callback The callback to handle whichever event\n   */\n\n  function Debouncer(callback) {\n    this.callback = callback;\n    this.ticking = false;\n  }\n\n  Debouncer.prototype = {\n    constructor: Debouncer,\n\n    /**\n     * dispatches the event to the supplied callback\n     * @private\n     */\n    update: function () {\n      this.callback && this.callback();\n      this.ticking = false;\n    },\n\n    /**\n     * ensures events don't get stacked\n     * @private\n     */\n    requestTick: function () {\n      if (!this.ticking) {\n        requestAnimationFrame(this.rafCallback || (this.rafCallback = this.update.bind(this)));\n        this.ticking = true;\n      }\n    },\n\n    /**\n     * Attach this as the event listeners\n     */\n    handleEvent: function () {\n      this.requestTick();\n    }\n  };\n  /**\n   * Check if object is part of the DOM\n   * @constructor\n   * @param {Object} obj element to check\n   */\n\n  function isDOMElement(obj) {\n    return obj && typeof window !== 'undefined' && (obj === window || obj.nodeType);\n  }\n  /**\n   * Helper function for extending objects\n   */\n\n\n  function extend(object\n  /*, objectN ... */\n  ) {\n    if (arguments.length <= 0) {\n      throw new Error('Missing arguments in extend function');\n    }\n\n    var result = object || {},\n        key,\n        i;\n\n    for (i = 1; i < arguments.length; i++) {\n      var replacement = arguments[i] || {};\n\n      for (key in replacement) {\n        // Recurse into object except if the object is a DOM element\n        if (typeof result[key] === 'object' && !isDOMElement(result[key])) {\n          result[key] = extend(result[key], replacement[key]);\n        } else {\n          result[key] = result[key] || replacement[key];\n        }\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Helper function for normalizing tolerance option to object format\n   */\n\n\n  function normalizeTolerance(t) {\n    return t === Object(t) ? t : {\n      down: t,\n      up: t\n    };\n  }\n  /**\n   * UI enhancement for fixed headers.\n   * Hides header when scrolling down\n   * Shows header when scrolling up\n   * @constructor\n   * @param {DOMElement} elem the header element\n   * @param {Object} options options for the widget\n   */\n\n\n  function Headroom(elem, options) {\n    options = extend(options, Headroom.options);\n    this.lastKnownScrollY = 0;\n    this.elem = elem;\n    this.tolerance = normalizeTolerance(options.tolerance);\n    this.classes = options.classes;\n    this.offset = options.offset;\n    this.scroller = options.scroller;\n    this.initialised = false;\n    this.onPin = options.onPin;\n    this.onUnpin = options.onUnpin;\n    this.onTop = options.onTop;\n    this.onNotTop = options.onNotTop;\n    this.onBottom = options.onBottom;\n    this.onNotBottom = options.onNotBottom;\n  }\n\n  Headroom.prototype = {\n    constructor: Headroom,\n\n    /**\n     * Initialises the widget\n     */\n    init: function () {\n      if (!Headroom.cutsTheMustard) {\n        return;\n      }\n\n      this.debouncer = new Debouncer(this.update.bind(this));\n      this.elem.classList.add(this.classes.initial); // defer event registration to handle browser\n      // potentially restoring previous scroll position\n\n      setTimeout(this.attachEvent.bind(this), 100);\n      return this;\n    },\n\n    /**\n     * Unattaches events and removes any classes that were added\n     */\n    destroy: function () {\n      var classes = this.classes;\n      this.initialised = false;\n\n      for (var key in classes) {\n        if (classes.hasOwnProperty(key)) {\n          this.elem.classList.remove(classes[key]);\n        }\n      }\n\n      this.scroller.removeEventListener('scroll', this.debouncer, false);\n    },\n\n    /**\n     * Attaches the scroll event\n     * @private\n     */\n    attachEvent: function () {\n      if (!this.initialised) {\n        this.lastKnownScrollY = this.getScrollY();\n        this.initialised = true;\n        this.scroller.addEventListener('scroll', this.debouncer, false);\n        this.debouncer.handleEvent();\n      }\n    },\n\n    /**\n     * Unpins the header if it's currently pinned\n     */\n    unpin: function () {\n      var classList = this.elem.classList,\n          classes = this.classes;\n\n      if (classList.contains(classes.pinned) || !classList.contains(classes.unpinned)) {\n        classList.add(classes.unpinned);\n        classList.remove(classes.pinned);\n        this.onUnpin && this.onUnpin.call(this);\n      }\n    },\n\n    /**\n     * Pins the header if it's currently unpinned\n     */\n    pin: function () {\n      var classList = this.elem.classList,\n          classes = this.classes;\n\n      if (classList.contains(classes.unpinned)) {\n        classList.remove(classes.unpinned);\n        classList.add(classes.pinned);\n        this.onPin && this.onPin.call(this);\n      }\n    },\n\n    /**\n     * Handles the top states\n     */\n    top: function () {\n      var classList = this.elem.classList,\n          classes = this.classes;\n\n      if (!classList.contains(classes.top)) {\n        classList.add(classes.top);\n        classList.remove(classes.notTop);\n        this.onTop && this.onTop.call(this);\n      }\n    },\n\n    /**\n     * Handles the not top state\n     */\n    notTop: function () {\n      var classList = this.elem.classList,\n          classes = this.classes;\n\n      if (!classList.contains(classes.notTop)) {\n        classList.add(classes.notTop);\n        classList.remove(classes.top);\n        this.onNotTop && this.onNotTop.call(this);\n      }\n    },\n    bottom: function () {\n      var classList = this.elem.classList,\n          classes = this.classes;\n\n      if (!classList.contains(classes.bottom)) {\n        classList.add(classes.bottom);\n        classList.remove(classes.notBottom);\n        this.onBottom && this.onBottom.call(this);\n      }\n    },\n\n    /**\n     * Handles the not top state\n     */\n    notBottom: function () {\n      var classList = this.elem.classList,\n          classes = this.classes;\n\n      if (!classList.contains(classes.notBottom)) {\n        classList.add(classes.notBottom);\n        classList.remove(classes.bottom);\n        this.onNotBottom && this.onNotBottom.call(this);\n      }\n    },\n\n    /**\n     * Gets the Y scroll position\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY\n     * @return {Number} pixels the page has scrolled along the Y-axis\n     */\n    getScrollY: function () {\n      return this.scroller.pageYOffset !== undefined ? this.scroller.pageYOffset : this.scroller.scrollTop !== undefined ? this.scroller.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop;\n    },\n\n    /**\n     * Gets the height of the viewport\n     * @see http://andylangton.co.uk/blog/development/get-viewport-size-width-and-height-javascript\n     * @return {int} the height of the viewport in pixels\n     */\n    getViewportHeight: function () {\n      return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n    },\n\n    /**\n     * Gets the physical height of the DOM element\n     * @param  {Object}  elm the element to calculate the physical height of which\n     * @return {int}     the physical height of the element in pixels\n     */\n    getElementPhysicalHeight: function (elm) {\n      return Math.max(elm.offsetHeight, elm.clientHeight);\n    },\n\n    /**\n     * Gets the physical height of the scroller element\n     * @return {int} the physical height of the scroller element in pixels\n     */\n    getScrollerPhysicalHeight: function () {\n      return this.scroller === window || this.scroller === document.body ? this.getViewportHeight() : this.getElementPhysicalHeight(this.scroller);\n    },\n\n    /**\n     * Gets the height of the document\n     * @see http://james.padolsey.com/javascript/get-document-height-cross-browser/\n     * @return {int} the height of the document in pixels\n     */\n    getDocumentHeight: function () {\n      var body = document.body,\n          documentElement = document.documentElement;\n      return Math.max(body.scrollHeight, documentElement.scrollHeight, body.offsetHeight, documentElement.offsetHeight, body.clientHeight, documentElement.clientHeight);\n    },\n\n    /**\n     * Gets the height of the DOM element\n     * @param  {Object}  elm the element to calculate the height of which\n     * @return {int}     the height of the element in pixels\n     */\n    getElementHeight: function (elm) {\n      return Math.max(elm.scrollHeight, elm.offsetHeight, elm.clientHeight);\n    },\n\n    /**\n     * Gets the height of the scroller element\n     * @return {int} the height of the scroller element in pixels\n     */\n    getScrollerHeight: function () {\n      return this.scroller === window || this.scroller === document.body ? this.getDocumentHeight() : this.getElementHeight(this.scroller);\n    },\n\n    /**\n     * determines if the scroll position is outside of document boundaries\n     * @param  {int}  currentScrollY the current y scroll position\n     * @return {bool} true if out of bounds, false otherwise\n     */\n    isOutOfBounds: function (currentScrollY) {\n      var pastTop = currentScrollY < 0,\n          pastBottom = currentScrollY + this.getScrollerPhysicalHeight() > this.getScrollerHeight();\n      return pastTop || pastBottom;\n    },\n\n    /**\n     * determines if the tolerance has been exceeded\n     * @param  {int} currentScrollY the current scroll y position\n     * @return {bool} true if tolerance exceeded, false otherwise\n     */\n    toleranceExceeded: function (currentScrollY, direction) {\n      return Math.abs(currentScrollY - this.lastKnownScrollY) >= this.tolerance[direction];\n    },\n\n    /**\n     * determine if it is appropriate to unpin\n     * @param  {int} currentScrollY the current y scroll position\n     * @param  {bool} toleranceExceeded has the tolerance been exceeded?\n     * @return {bool} true if should unpin, false otherwise\n     */\n    shouldUnpin: function (currentScrollY, toleranceExceeded) {\n      var scrollingDown = currentScrollY > this.lastKnownScrollY,\n          pastOffset = currentScrollY >= this.offset;\n      return scrollingDown && pastOffset && toleranceExceeded;\n    },\n\n    /**\n     * determine if it is appropriate to pin\n     * @param  {int} currentScrollY the current y scroll position\n     * @param  {bool} toleranceExceeded has the tolerance been exceeded?\n     * @return {bool} true if should pin, false otherwise\n     */\n    shouldPin: function (currentScrollY, toleranceExceeded) {\n      var scrollingUp = currentScrollY < this.lastKnownScrollY,\n          pastOffset = currentScrollY <= this.offset;\n      return scrollingUp && toleranceExceeded || pastOffset;\n    },\n\n    /**\n     * Handles updating the state of the widget\n     */\n    update: function () {\n      var currentScrollY = this.getScrollY(),\n          scrollDirection = currentScrollY > this.lastKnownScrollY ? 'down' : 'up',\n          toleranceExceeded = this.toleranceExceeded(currentScrollY, scrollDirection);\n\n      if (this.isOutOfBounds(currentScrollY)) {\n        // Ignore bouncy scrolling in OSX\n        return;\n      }\n\n      if (currentScrollY <= this.offset) {\n        this.top();\n      } else {\n        this.notTop();\n      }\n\n      if (currentScrollY + this.getViewportHeight() >= this.getScrollerHeight()) {\n        this.bottom();\n      } else {\n        this.notBottom();\n      }\n\n      if (this.shouldUnpin(currentScrollY, toleranceExceeded)) {\n        this.unpin();\n      } else if (this.shouldPin(currentScrollY, toleranceExceeded)) {\n        this.pin();\n      }\n\n      this.lastKnownScrollY = currentScrollY;\n    }\n  };\n  /**\n   * Default options\n   * @type {Object}\n   */\n\n  Headroom.options = {\n    tolerance: {\n      up: 0,\n      down: 0\n    },\n    offset: 0,\n    scroller: window,\n    classes: {\n      pinned: 'headroom--pinned',\n      unpinned: 'headroom--unpinned',\n      top: 'headroom--top',\n      notTop: 'headroom--not-top',\n      bottom: 'headroom--bottom',\n      notBottom: 'headroom--not-bottom',\n      initial: 'headroom'\n    }\n  };\n  Headroom.cutsTheMustard = typeof features !== 'undefined' && features.rAF && features.bind && features.classList;\n  return Headroom;\n});","map":null,"metadata":{},"sourceType":"script"}